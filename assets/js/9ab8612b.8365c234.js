"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[3102],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return u}});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),d=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},p=function(e){var t=d(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),h=d(a),u=i,m=h["".concat(l,".").concat(u)]||h[u]||c[u]||r;return a?n.createElement(m,s(s({ref:t},p),{},{components:a})):n.createElement(m,s({ref:t},p))}));function u(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,s=new Array(r);s[0]=h;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,s[1]=o;for(var d=2;d<r;d++)s[d]=a[d];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"},573:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return p},default:function(){return h}});var n=a(7462),i=a(3366),r=(a(7294),a(3905)),s=["components"],o={id:"dao-registry",title:"Registry"},l=void 0,d={unversionedId:"contracts/core/dao-registry",id:"contracts/core/dao-registry",isDocsHomePage:!1,title:"Registry",description:"The DAO Registry contract is the identity of the DAO. This is the contract address that every adapter usually interacts with.",source:"@site/docs/contracts/core/DaoRegistry.md",sourceDirName:"contracts/core",slug:"/contracts/core/dao-registry",permalink:"/docs/contracts/core/dao-registry",editUrl:"https://github.com/openlawteam/tribute-contracts/edit/docs/website/docs/contracts/core/DaoRegistry.md",tags:[],version:"current",frontMatter:{id:"dao-registry",title:"Registry"},sidebar:"docs",previous:{title:"How to create an Extension",permalink:"/docs/tutorial/extensions/creating-an-extension"},next:{title:"Factory",permalink:"/docs/contracts/core/dao-factory"}},p=[{value:"DAO State",id:"dao-state",children:[]},{value:"Access Flags",id:"access-flags",children:[]},{value:"Structs",id:"structs",children:[{value:"Proposal",id:"proposal",children:[]},{value:"Member",id:"member",children:[]},{value:"Checkpoint",id:"checkpoint",children:[]},{value:"AdapterEntry",id:"adapterentry",children:[]},{value:"ExtensionEntry",id:"extensionentry",children:[]}]},{value:"Storage",id:"storage",children:[{value:"public members",id:"public-members",children:[]},{value:"private _members",id:"private-_members",children:[]},{value:"public memberAddressesByDelegatedKey",id:"public-memberaddressesbydelegatedkey",children:[]},{value:"checkpoints",id:"checkpoints",children:[]},{value:"numCheckpoints",id:"numcheckpoints",children:[]},{value:"public state",id:"public-state",children:[]},{value:"public proposals",id:"public-proposals",children:[]},{value:"public adapters",id:"public-adapters",children:[]},{value:"public inverseAdapters",id:"public-inverseadapters",children:[]},{value:"public extensions",id:"public-extensions",children:[]},{value:"public inverseExtensions",id:"public-inverseextensions",children:[]},{value:"public mainConfiguration",id:"public-mainconfiguration",children:[]},{value:"public addressConfiguration",id:"public-addressconfiguration",children:[]}]},{value:"Functions",id:"functions",children:[{value:"initialize",id:"initialize",children:[]},{value:"finalizeDao",id:"finalizedao",children:[]},{value:"setConfiguration",id:"setconfiguration",children:[]},{value:"setAddressConfiguration",id:"setaddressconfiguration",children:[]},{value:"potentialNewMember",id:"potentialnewmember",children:[]},{value:"getConfiguration",id:"getconfiguration",children:[]},{value:"getAddressConfiguration",id:"getaddressconfiguration",children:[]},{value:"addExtension",id:"addextension",children:[]},{value:"removeExtension",id:"removeextension",children:[]},{value:"setAclToExtensionForAdapter",id:"setacltoextensionforadapter",children:[]},{value:"replaceAdapter",id:"replaceadapter",children:[]},{value:"isExtension",id:"isextension",children:[]},{value:"isAdapter",id:"isadapter",children:[]},{value:"hasAdapterAccess",id:"hasadapteraccess",children:[]},{value:"hasAdapterAccessToExtension",id:"hasadapteraccesstoextension",children:[]},{value:"getAdapterAddress",id:"getadapteraddress",children:[]},{value:"getExtensionAddress",id:"getextensionaddress",children:[]},{value:"submitProposal",id:"submitproposal",children:[]},{value:"sponsorProposal",id:"sponsorproposal",children:[]},{value:"processProposal",id:"processproposal",children:[]},{value:"_setProposalFlag",id:"_setproposalflag",children:[]},{value:"isMember(address addr)",id:"ismemberaddress-addr",children:[]},{value:"getProposalFlag",id:"getproposalflag",children:[]},{value:"getMemberFlag",id:"getmemberflag",children:[]},{value:"getNbMembers",id:"getnbmembers",children:[]},{value:"getMemberAddress",id:"getmemberaddress",children:[]},{value:"updateDelegateKey",id:"updatedelegatekey",children:[]},{value:"getAddressIfDelegated",id:"getaddressifdelegated",children:[]},{value:"getCurrentDelegateKey(address memberAddr)",id:"getcurrentdelegatekeyaddress-memberaddr",children:[]},{value:"getPreviousDelegateKey",id:"getpreviousdelegatekey",children:[]},{value:"getPriorDelegateKey",id:"getpriordelegatekey",children:[]},{value:"_createNewDelegateCheckpoint",id:"_createnewdelegatecheckpoint",children:[]}]},{value:"Events",id:"events",children:[{value:"Proposals",id:"proposals",children:[]},{value:"Adapters",id:"adapters",children:[]},{value:"Members",id:"members",children:[]},{value:"Configuration",id:"configuration",children:[]}]}],c={toc:p};function h(e){var t=e.components,a=(0,i.Z)(e,s);return(0,r.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The DAO Registry contract is the identity of the DAO. This is the contract address that every adapter usually interacts with."),(0,r.kt)("p",null,"The scope of the registry is to manage the following:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"The adapter registry - which adapter is being used by this DAO and which access it has to the DAO state."),(0,r.kt)("li",{parentName:"ul"},"The extension registry - which extension is part of the DAO and the adapter's access to it."),(0,r.kt)("li",{parentName:"ul"},"Members registry - whether members exist, their delegate key and their access flags.")),(0,r.kt)("div",{className:"admonition admonition-important alert alert--info"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"important")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Each non-constant function in the DAO Registry has an access control modifier ",(0,r.kt)("inlineCode",{parentName:"p"},"hasAccess")," linked to it, to make sure the caller has the right to call it."))),(0,r.kt)("p",null,"The DaoRegistry.sol contract tracks the state of the DAO for 1) Adapter and Extension access, 2) State of Proposals, 3) Membership status. If an Adapter needs to access the DAO Registry, it must be registered to the DAO with the correct access flags."),(0,r.kt)("h2",{id:"dao-state"},"DAO State"),(0,r.kt)("p",null,"The DAO can be in one of the following states:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"CREATION"),": when the DAO is being deployed via ",(0,r.kt)("inlineCode",{parentName:"li"},"initializeDao"),", but is not ready to be used."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"READY"),": when the function ",(0,r.kt)("inlineCode",{parentName:"li"},"finalizeDao")," has been called, and is now ready to be used.")),(0,r.kt)("div",{className:"admonition admonition-tip alert alert--success"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"Once the DaoState is changed to ",(0,r.kt)("inlineCode",{parentName:"p"},"READY"),", then the only way to add additional Adapters is via proposal process using the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("a",{parentName:"strong",href:"/docs/contracts/adapters/configuration/managing-adapter"},"Managing Adapter")),"."))),(0,r.kt)("h2",{id:"access-flags"},"Access Flags"),(0,r.kt)("p",null,"The are three main categories of Access Flags for the DAO Registry Contract:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"MemberFlags"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"EXISTS"),": right to check if a given address is already part of the DAO. Useful to restrict the DAO features that need to be access by members only."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"ProposalFlag"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"EXISTS"),": right to check if a given proposal id already exists in the DAO storage."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SPONSORED"),": right to check if a given proposal id was already sponsored."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"PROCESSED"),": right to check if a griven proposal id was already processed."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"AclFlag"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"REPLACE_ADAPTER"),": right to add/remove/replace an adapter, function ",(0,r.kt)("inlineCode",{parentName:"li"},"dao.replaceAdapter"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SUBMIT_PROPOSAL"),": right to submit a proposal, function ",(0,r.kt)("inlineCode",{parentName:"li"},"dao.submitProposal"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"UPDATE_DELEGATE_KEY"),": right to update the delegate key of a member, function ",(0,r.kt)("inlineCode",{parentName:"li"},"dao.updateDelegatedKey"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SET_CONFIGURATION"),": right to set custom configurations parameters, function ",(0,r.kt)("inlineCode",{parentName:"li"},"dao.setConfiguration"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"ADD_EXTENSION"),": right to add an extension, function ",(0,r.kt)("inlineCode",{parentName:"li"},"dao.addExtension"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"REMOVE_EXTENSION"),": right to remove an extension, function ",(0,r.kt)("inlineCode",{parentName:"li"},"dao.removeExtension"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"NEW_MEMBER"),": right to add a new potential member to the DAO, function ",(0,r.kt)("inlineCode",{parentName:"li"},"dao.potentialNewMember"),".")))),(0,r.kt)("h2",{id:"structs"},"Structs"),(0,r.kt)("h3",{id:"proposal"},"Proposal"),(0,r.kt)("p",null,"The structure to track all the proposals in the DAO and their state (EXISTS, SPONSORED, PROCESSED)."),(0,r.kt)("h3",{id:"member"},"Member"),(0,r.kt)("p",null,"The structure to track all the members in the DAO and their state (EXISTS)."),(0,r.kt)("h3",{id:"checkpoint"},"Checkpoint"),(0,r.kt)("p",null,"Tribute makes use of the off-chain voting mechanism Snapshot. The ",(0,r.kt)("inlineCode",{parentName:"p"},"Checkpoint")," struct assists with verifying the optimistic voting and proposal mechanisms at various blocktimes. See, ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/snapshot-labs"},"https://github.com/snapshot-labs"),"."),(0,r.kt)("h3",{id:"adapterentry"},"AdapterEntry"),(0,r.kt)("p",null,"When an Adapter is added to ",(0,r.kt)("inlineCode",{parentName:"p"},"DaoRegistry")," via the function ",(0,r.kt)("inlineCode",{parentName:"p"},"replaceAdapter"),", a bytes32 ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," and a uint256 ",(0,r.kt)("inlineCode",{parentName:"p"},"acl")," are parameters assigned to the Adapter for use in identifying the Adapter."),(0,r.kt)("h3",{id:"extensionentry"},"ExtensionEntry"),(0,r.kt)("p",null,"When an Extension is added to ",(0,r.kt)("inlineCode",{parentName:"p"},"DaoRegistry")," via ",(0,r.kt)("inlineCode",{parentName:"p"},"addExtenstion")," a bytes32 ",(0,r.kt)("inlineCode",{parentName:"p"},"id")," and a uint256 ",(0,r.kt)("inlineCode",{parentName:"p"},"acl")," are parameters assigned to the Extension for use in identifying the Extension."),(0,r.kt)("h2",{id:"storage"},"Storage"),(0,r.kt)("h3",{id:"public-members"},"public members"),(0,r.kt)("p",null,"Mapping of all the members. Member struct contains the flags uint."),(0,r.kt)("h3",{id:"private-_members"},"private ","_","members"),(0,r.kt)("p",null,"List of all the member addresses. Useful to iterate through members."),(0,r.kt)("h3",{id:"public-memberaddressesbydelegatedkey"},"public memberAddressesByDelegatedKey"),(0,r.kt)("p",null,"Mapping of the member address by delegate key (think inverted mapping from members by delegate key)."),(0,r.kt)("h3",{id:"checkpoints"},"checkpoints"),(0,r.kt)("p",null,"Delegate key checkpoints. This is useful to know what the delegate key is at a certain point in time. A checkpoint is a data structure that allows storing data on a per-block basis and is originally inspired by the Compound contracts."),(0,r.kt)("h3",{id:"numcheckpoints"},"numCheckpoints"),(0,r.kt)("p",null,"Checkpoint lengths per member address."),(0,r.kt)("h3",{id:"public-state"},"public state"),(0,r.kt)("p",null,"Dao state. This is used to know if the DAO is currently being set up or if it is already running. Useful to configure it."),(0,r.kt)("h3",{id:"public-proposals"},"public proposals"),(0,r.kt)("p",null,"Mapping of all the proposals for the DAO. Each proposal has an adapterAddress (which adapter created it) and flags to define its state."),(0,r.kt)("h3",{id:"public-adapters"},"public adapters"),(0,r.kt)("p",null,"Mapping of all the adapters. bytes32 is the keccak256 of their name and address."),(0,r.kt)("h3",{id:"public-inverseadapters"},"public inverseAdapters"),(0,r.kt)("p",null,"Mapping of adapter details. For each address, we can get its id (keccak256(name)) and its acl (access control, which function in the DAO it has access to)."),(0,r.kt)("h3",{id:"public-extensions"},"public extensions"),(0,r.kt)("p",null,'Mapping of each extension. Like for adapters, the key here is keccak256(name) (e.g., keccak256("bank"))'),(0,r.kt)("h3",{id:"public-inverseextensions"},"public inverseExtensions"),(0,r.kt)("p",null,"Mapping of extension details. For each extension address, you get its id (keccak256(name)) and a mapping from adapter address => access control.\nAccess control for each extension is centralized in the DaoRegistry to avoid each extension implementing its own ACL system."),(0,r.kt)("h3",{id:"public-mainconfiguration"},"public mainConfiguration"),(0,r.kt)("p",null,"Generic configuration mapping from key (keccak256(name)) to any type that can be encoded in 256 bytes (does not need to be uint, could be bytes32 too)."),(0,r.kt)("h3",{id:"public-addressconfiguration"},"public addressConfiguration"),(0,r.kt)("p",null,"Since addresses are not encoded in 256 bytes, we need a separate configuration mapping for this type."),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("div",{className:"admonition admonition-caution alert alert--warning"},(0,r.kt)("div",{parentName:"div",className:"admonition-heading"},(0,r.kt)("h5",{parentName:"div"},(0,r.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,r.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"16",height:"16",viewBox:"0 0 16 16"},(0,r.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M8.893 1.5c-.183-.31-.52-.5-.887-.5s-.703.19-.886.5L.138 13.499a.98.98 0 0 0 0 1.001c.193.31.53.501.886.501h13.964c.367 0 .704-.19.877-.5a1.03 1.03 0 0 0 .01-1.002L8.893 1.5zm.133 11.497H6.987v-2.003h2.039v2.003zm0-3.004H6.987V5.987h2.039v4.006z"}))),"caution")),(0,r.kt)("div",{parentName:"div",className:"admonition-content"},(0,r.kt)("p",{parentName:"div"},"The constructor function is non-existent, because this is a Cloneable contract. See, ",(0,r.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1167"},"https://eips.ethereum.org/EIPS/eip-1167")))),(0,r.kt)("h3",{id:"initialize"},"initialize"),(0,r.kt)("p",null,"Initializes the DAO by creating the initial members who are 1) the DAO creator passed to the function, 2) the account passed to the function which paid for the transaction to create the DAO, and 3) the DaoFactory calling this function."),(0,r.kt)("h3",{id:"finalizedao"},"finalizeDao"),(0,r.kt)("p",null,"Mark the DAO as finalized. After that, changes can only be made through adapters."),(0,r.kt)("h3",{id:"setconfiguration"},"setConfiguration"),(0,r.kt)("p",null,"Set a generic configuration entry for the DAO.\nOnly adapters with access to this function can do it."),(0,r.kt)("h3",{id:"setaddressconfiguration"},"setAddressConfiguration"),(0,r.kt)("p",null,"Set an address configuration entry for the DAO.\nOnly adapters with access to this function can do it."),(0,r.kt)("h3",{id:"potentialnewmember"},"potentialNewMember"),(0,r.kt)("p",null,"This functions checks if the member exists in the DAO. If the member does not exist,\nit creates the entry for the new member.\nThat means creating an entry in the members mapping, setting the delegate key to be the same address as the new member and adding the address to the members list."),(0,r.kt)("h3",{id:"getconfiguration"},"getConfiguration"),(0,r.kt)("p",null,"Get the generic config entry by passing the keccak256(config name)."),(0,r.kt)("h3",{id:"getaddressconfiguration"},"getAddressConfiguration"),(0,r.kt)("p",null,"Get the address config entry by passing the keccak256(config name)."),(0,r.kt)("h3",{id:"addextension"},"addExtension"),(0,r.kt)("p",null,"Add a new extension to the registry. It first checks if the extension id is already used and reverts if it is the case.\nIt then adds the extension to the DAO and initializes it."),(0,r.kt)("h3",{id:"removeextension"},"removeExtension"),(0,r.kt)("p",null,"Removes the extension by extension id. It reverts if no extension has been registered for that id (keccak256(name))."),(0,r.kt)("h3",{id:"setacltoextensionforadapter"},"setAclToExtensionForAdapter"),(0,r.kt)("p",null,"Sets the access control for a particular adapter (by address) to a specific extension.\nBoth adapter and extension need to be already registered to the DAO."),(0,r.kt)("h3",{id:"replaceadapter"},"replaceAdapter"),(0,r.kt)("p",null,"Adds, removes or replaces an adapter om the DAO registry. It also sets the access control.\nThe adapter can be added only if the adapter id is not already in use.\nTo remove an adapter from the DAO just set the address to 0x0."),(0,r.kt)("h3",{id:"isextension"},"isExtension"),(0,r.kt)("p",null,"Checks whether the address is registered as an extension in the DAO."),(0,r.kt)("h3",{id:"isadapter"},"isAdapter"),(0,r.kt)("p",null,"Checks whether the address is registered as an adapter in the DAO."),(0,r.kt)("h3",{id:"hasadapteraccess"},"hasAdapterAccess"),(0,r.kt)("p",null,"Checks whether the adapter has access to a certain flag in the DAO."),(0,r.kt)("h3",{id:"hasadapteraccesstoextension"},"hasAdapterAccessToExtension"),(0,r.kt)("p",null,"Checks whether a certain adapter has access to a certain extension in the DAO."),(0,r.kt)("h3",{id:"getadapteraddress"},"getAdapterAddress"),(0,r.kt)("p",null,"Returns the adapter address registered for this adapterId and reverts if not found."),(0,r.kt)("p",null,"The reason we revert here is to avoid the need to check everywhere that the return value is 0x0 when we want to use an adapter."),(0,r.kt)("h3",{id:"getextensionaddress"},"getExtensionAddress"),(0,r.kt)("p",null,"Returns the extension address registered for this extensionId and reverts if not found."),(0,r.kt)("p",null,"The reason we revert here is to avoid the need to check everywhere that the return value is 0x0 when we want to use an extension."),(0,r.kt)("h3",{id:"submitproposal"},"submitProposal"),(0,r.kt)("p",null,"Creates a proposal entry for the DAO.\nIt checks that the proposal was not previously created."),(0,r.kt)("h3",{id:"sponsorproposal"},"sponsorProposal"),(0,r.kt)("p",null,"Marks an existing proposal as sponsored.\nsaves which voting adapter is being used for this proposal.\nChecks that the proposal has not been sponsored yet.\nChecks that the proposal exists.\nChecks that the adapter that sponsors the proposal is the one that submitted it.\nChecks that the proposal has not been processed yet.\nChecks that the member sponsoring the proposal is an active member."),(0,r.kt)("h3",{id:"processproposal"},"processProposal"),(0,r.kt)("p",null,"Marks an existing proposal as processed.\nChecks that the proposal has not been processed already and that it exists."),(0,r.kt)("h3",{id:"_setproposalflag"},"_","setProposalFlag"),(0,r.kt)("p",null,"Internal utility function to set a flag to a proposal.\nIt checks that the proposal exists and that the flag has not been already set."),(0,r.kt)("h3",{id:"ismemberaddress-addr"},"isMember(address addr)"),(0,r.kt)("p",null,"Returns true if the address is the delegate key of an existing member"),(0,r.kt)("h3",{id:"getproposalflag"},"getProposalFlag"),(0,r.kt)("p",null,"Helper function to get the flag value for a proposal."),(0,r.kt)("h3",{id:"getmemberflag"},"getMemberFlag"),(0,r.kt)("p",null,"Helper function to get the flag value for a member."),(0,r.kt)("h3",{id:"getnbmembers"},"getNbMembers"),(0,r.kt)("p",null,"Returns how many members have been registered in the DAO."),(0,r.kt)("h3",{id:"getmemberaddress"},"getMemberAddress"),(0,r.kt)("p",null,"Gets an address at a certain index in the members list."),(0,r.kt)("h3",{id:"updatedelegatekey"},"updateDelegateKey"),(0,r.kt)("p",null,"Updates the delegate key of a certain member.\nIt checks that the delegate key is not being used by another member and is not the address of an existing member.\nIt also checks that the member exists."),(0,r.kt)("p",null,"If all the checks pass, the delegate key is updated and a delegate key checkpoint is created."),(0,r.kt)("h3",{id:"getaddressifdelegated"},"getAddressIfDelegated"),(0,r.kt)("p",null,"Returns the member address if the address is used as a delegate key or the address itself if it is not."),(0,r.kt)("h3",{id:"getcurrentdelegatekeyaddress-memberaddr"},"getCurrentDelegateKey(address memberAddr)"),(0,r.kt)("p",null,"Returns the current delegate key for a member address. The member's delegate key is an alternative address to their original membership address that they have specified for interacting with the DAO. This delegation can be used for a number of different reasons (attack, reorg, technical issues, tax)."),(0,r.kt)("h3",{id:"getpreviousdelegatekey"},"getPreviousDelegateKey"),(0,r.kt)("p",null,"Returns the previous delegate key for a member address. It is used to prepare the checkpoint."),(0,r.kt)("h3",{id:"getpriordelegatekey"},"getPriorDelegateKey"),(0,r.kt)("p",null,"Returns the delegate key for a member at a certain block number.\nIf none are found, the memberAddr is returned instead."),(0,r.kt)("h3",{id:"_createnewdelegatecheckpoint"},"_","createNewDelegateCheckpoint"),(0,r.kt)("p",null,"Writes a new checkpoint for a specific member."),(0,r.kt)("h2",{id:"events"},"Events"),(0,r.kt)("h3",{id:"proposals"},"Proposals"),(0,r.kt)("p",null,"The proposal order follows Moloch v2"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A proposal is submitted")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"event SubmittedProposal(bytes32 proposalId, uint256 flags);"))),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"Then it sponsored by a member")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"event SponsoredProposal(bytes32 proposalId, uint256 flags, address votingAdapter);"))),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},"After a proposal is voted on, it can finally be processed")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"event ProcessedProposal(bytes32 proposalId, uint256 flags);"))),(0,r.kt)("h3",{id:"adapters"},"Adapters"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A new adapter is added (registereds) to the DAO")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"event AdapterAdded(bytes32 adapterId,address adapterAddress,uint256 flags);"))),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"An adapter is removed from the DAO")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"event AdapterRemoved(bytes32 adapterId);"))),(0,r.kt)("h3",{id:"members"},"Members"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"When a member updates the delegated key")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"event UpdateDelegateKey(address memberAddress, address newDelegateKey);"))),(0,r.kt)("h3",{id:"configuration"},"Configuration"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"When a new configuration is added/erased")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"event ConfigurationUpdated(bytes32 key, uint256 value);"))),(0,r.kt)("ol",{start:2},(0,r.kt)("li",{parentName:"ol"},"When the Address configuration is updated")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"event AddressConfigurationUpdated(bytes32 key, address value);"))))}h.isMDXComponent=!0}}]);