"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2795],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,u=o(e,["components","mdxType","originalType","parentName"]),p=l(n),h=a,g=p["".concat(c,".").concat(h)]||p[h]||d[h]||r;return n?i.createElement(g,s(s({ref:t},u),{},{components:n})):i.createElement(g,s({ref:t},u))}));function h(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,s=new Array(r);s[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var l=2;l<r;l++)s[l]=n[l];return i.createElement.apply(null,s)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6596:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return o},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return u},default:function(){return p}});var i=n(7462),a=n(3366),r=(n(7294),n(3905)),s=["components"],o={id:"erc1271-extension",title:"ERC1271"},c=void 0,l={unversionedId:"contracts/extensions/erc1271-extension",id:"contracts/extensions/erc1271-extension",isDocsHomePage:!1,title:"ERC1271",description:"The ERC1271 extension allows DAOs to collectively sign messages and typed data through signatures. ERC1271 is a contract signature standard that enables smart contract wallets to behave like EOAs (externally owned accounts). Signatures are critical when interacting with various types of decentralized applications. Developers use signatures for authentication, meta-transactions, order books, and anything that requires delegated permission or proof of ownership of an address. ERC1271 has widespread adoption and is used in applications like Argent and Snapshot.",source:"@site/docs/contracts/extensions/ERC1271.md",sourceDirName:"contracts/extensions",slug:"/contracts/extensions/erc1271-extension",permalink:"/docs/contracts/extensions/erc1271-extension",editUrl:"https://github.com/openlawteam/tribute-contracts/edit/docs/website/docs/contracts/extensions/ERC1271.md",tags:[],version:"current",frontMatter:{id:"erc1271-extension",title:"ERC1271"},sidebar:"docs",previous:{title:"Executor",permalink:"/docs/contracts/extensions/executor-extension"},next:{title:"ERC1155",permalink:"/docs/contracts/extensions/erc1155-extension"}},u=[{value:"Access Flags",id:"access-flags",children:[]},{value:"Structs",id:"structs",children:[{value:"DAOSignature",id:"daosignature",children:[]}]},{value:"Storage",id:"storage",children:[{value:"public dao",id:"public-dao",children:[]},{value:"public initialized",id:"public-initialized",children:[]},{value:"public signatures",id:"public-signatures",children:[]}]},{value:"Dependencies",id:"dependencies",children:[{value:"DaoRegistry",id:"daoregistry",children:[]}]},{value:"Functions",id:"functions",children:[{value:"function initialize",id:"function-initialize",children:[]},{value:"function sign",id:"function-sign",children:[]},{value:"function isValidSignature",id:"function-isvalidsignature",children:[]}]},{value:"Events",id:"events",children:[]}],d={toc:u};function p(e){var t=e.components,n=(0,a.Z)(e,s);return(0,r.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ERC1271 extension allows DAOs to collectively sign messages and typed data through signatures. ERC1271 is a contract signature standard that enables smart contract wallets to behave like EOAs (externally owned accounts). Signatures are critical when interacting with various types of decentralized applications. Developers use signatures for authentication, meta-transactions, order books, and anything that requires delegated permission or proof of ownership of an address. ERC1271 has widespread adoption and is used in applications like Argent and Snapshot."),(0,r.kt)("p",null,"In order to register a signature with the DAO, a member must submit a proposal in which they specify the signature message digest, the signature, and the magic value to return on success."),(0,r.kt)("p",null,"The message digest must be the hash of the message to sign. This can be a simple message hash, a personal signature (message with special prefix), or a typed data signature (message created using structured data)."),(0,r.kt)("p",null,"The proposal enters the voting process."),(0,r.kt)("p",null,"If the vote passes, the extension returns the magic value when queried via the ERC1271 interface."),(0,r.kt)("h2",{id:"access-flags"},"Access Flags"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SIGN"),": right to store a signature into the contract ",(0,r.kt)("em",{parentName:"li"},"signatures")," storage.")),(0,r.kt)("h2",{id:"structs"},"Structs"),(0,r.kt)("h3",{id:"daosignature"},"DAOSignature"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"signatureProposals"),": all signature proposals handled by each DAO."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SignatureDetails"),":",(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"signature"),": the signature associated with this proposal. May be used to encode other attributes for efficiency, since it is not a real signature and would just be wasted storage space."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"msgHash"),": the digest of the data to sign."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"magicValue"),": the value to return if a signature proposal has passed.")))),(0,r.kt)("h2",{id:"storage"},"Storage"),(0,r.kt)("h3",{id:"public-dao"},"public dao"),(0,r.kt)("p",null,"The DAO address that this extension belongs to."),(0,r.kt)("h3",{id:"public-initialized"},"public initialized"),(0,r.kt)("p",null,"Internally tracks deployment under ERC-1167 proxy pattern."),(0,r.kt)("h3",{id:"public-signatures"},"public signatures"),(0,r.kt)("p",null,"Keeps track of all signatures provided through ",(0,r.kt)("inlineCode",{parentName:"p"},"sign")," function, so they can be verified."),(0,r.kt)("h2",{id:"dependencies"},"Dependencies"),(0,r.kt)("h3",{id:"daoregistry"},"DaoRegistry"),(0,r.kt)("h2",{id:"functions"},"Functions"),(0,r.kt)("h3",{id:"function-initialize"},"function initialize"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"/**\n  * @notice Initialises the ERC1271 extension to be associated with a DAO\n  * @dev Can only be called once\n  * @param creator The DAO's creator, who will be an initial member\n  */\nfunction initialize(DaoRegistry _dao, address creator) external\n")),(0,r.kt)("h3",{id:"function-sign"},"function sign"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"    /**\n     * @notice Registers a valid signature in the extension.\n     * @dev Only adapters/extensions with `SIGN` ACL can call this function.\n     * @param permissionHash The digest of the data to be signed.\n     * @param signatureHash The hash of the signature.\n     * @param magicValue The value to be returned by the ERC1271 interface upon success.\n     */\n    function sign(\n        bytes32 permissionHash,\n        bytes32 signatureHash,\n        bytes4 magicValue\n    ) public hasExtensionAccess(AclFlag.SIGN)\n")),(0,r.kt)("h3",{id:"function-isvalidsignature"},"function isValidSignature"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-solidity"},"    /**\n     * @notice Verifies if exists a signature based on the permissionHash, and checks if the provided signature matches the expected signatureHash.\n     * @param permissionHash The digest of the data to be signed.\n     * @param signature The signature in bytes to be encoded, hashed and verified.\n     * @return The magic number in bytes4 in case the signature is valid, otherwise it reverts.\n     */\n    function isValidSignature(bytes32 permissionHash, bytes memory signature)\n        public\n        view\n        override\n        returns (bytes4)\n    function isValidSignature(bytes32 permissionHash, bytes memory signature)\n        public\n        view\n        override\n        returns (bytes4)\n")),(0,r.kt)("h2",{id:"events"},"Events"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"No events are emitted.")))}p.isMDXComponent=!0}}]);